# 为什么要使用设计模式？

使用设计模式的根本原因是适应变化，为了增加代码复用率，是软件更具有维护性和可扩展性。

# 设计原则

- **单一职责原则**

就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性。

- **开闭原则 OCP**

一个软件实体（指的类、函数、模块等）应该对扩展开放，对修改关闭。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。

符合开闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。

- **里氏代替原则 LSP**

在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后，并且此时软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。

- **依赖倒置原则 DIP**

指的是抽象不应该依赖于细节，细节应该依赖于抽象，也就是提出的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。

- **接口隔离原则 ISP**

使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。

- **合成复用原则 CRP**

在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。

- **迪米特法则 LOD**

又叫最少知识原则（Least Knowledge Principle，LKP），指的是一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。

# 创建型模式

创建型模式就是用来创建对象的模式，抽象了实例化的过程。

所有的创建型模式都有两个共同点：

1. 它们都将系统使用哪些具体类的信息封装起来
2. 它们隐藏了这些类的实例是如何被创建和组织的

创建型模式包括单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式。

# 结构型模式

结构型模式，顾名思义讨论的是类和对象的结构 ，主要用来处理类或对象的组合。

包括两种类型：

1. 类结构型模式，指的是采用继承机制来组合接口或实现
2. 对象结构型模式，指的是通过组合对象的方式来实现新的功能。

包括适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式和代理模式。

# 行为型模式

行为型模式是对在不同对象之间划分责任和算法的抽象化。行为模式不仅仅关于类和对象，还关于它们之间的相互作用。

行为型模式又分为类的行为模式和对象的行为模式两种：

1. 类的行为模式——使用继承关系在几个类之间分配行为。
2. 对象的行为模式——使用对象聚合的方式来分配行为。

包括：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、状态模式、策略模式、责任链模式、访问者模式、解释器模式和备忘录模式。
